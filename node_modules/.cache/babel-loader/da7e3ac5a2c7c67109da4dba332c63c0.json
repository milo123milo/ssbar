{"ast":null,"code":"/*!\n  * @intlify/message-resolver v9.1.9\n  * (c) 2021 kazuya kawaguchi\n  * Released under the MIT License.\n  */\n\n/**\r\n * Original Utilities\r\n * written by kazuya kawaguchi\r\n */\nif (process.env.NODE_ENV !== 'production') ;\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction hasOwn(obj, key) {\n  return hasOwnProperty.call(obj, key);\n}\n\nconst isObject = val => // eslint-disable-line\nval !== null && typeof val === 'object';\n\nconst pathStateMachine = [];\npathStateMachine[0\n/* BEFORE_PATH */\n] = {\n  [\"w\"\n  /* WORKSPACE */\n  ]: [0\n  /* BEFORE_PATH */\n  ],\n  [\"i\"\n  /* IDENT */\n  ]: [3\n  /* IN_IDENT */\n  , 0\n  /* APPEND */\n  ],\n  [\"[\"\n  /* LEFT_BRACKET */\n  ]: [4\n  /* IN_SUB_PATH */\n  ],\n  [\"o\"\n  /* END_OF_FAIL */\n  ]: [7\n  /* AFTER_PATH */\n  ]\n};\npathStateMachine[1\n/* IN_PATH */\n] = {\n  [\"w\"\n  /* WORKSPACE */\n  ]: [1\n  /* IN_PATH */\n  ],\n  [\".\"\n  /* DOT */\n  ]: [2\n  /* BEFORE_IDENT */\n  ],\n  [\"[\"\n  /* LEFT_BRACKET */\n  ]: [4\n  /* IN_SUB_PATH */\n  ],\n  [\"o\"\n  /* END_OF_FAIL */\n  ]: [7\n  /* AFTER_PATH */\n  ]\n};\npathStateMachine[2\n/* BEFORE_IDENT */\n] = {\n  [\"w\"\n  /* WORKSPACE */\n  ]: [2\n  /* BEFORE_IDENT */\n  ],\n  [\"i\"\n  /* IDENT */\n  ]: [3\n  /* IN_IDENT */\n  , 0\n  /* APPEND */\n  ],\n  [\"0\"\n  /* ZERO */\n  ]: [3\n  /* IN_IDENT */\n  , 0\n  /* APPEND */\n  ]\n};\npathStateMachine[3\n/* IN_IDENT */\n] = {\n  [\"i\"\n  /* IDENT */\n  ]: [3\n  /* IN_IDENT */\n  , 0\n  /* APPEND */\n  ],\n  [\"0\"\n  /* ZERO */\n  ]: [3\n  /* IN_IDENT */\n  , 0\n  /* APPEND */\n  ],\n  [\"w\"\n  /* WORKSPACE */\n  ]: [1\n  /* IN_PATH */\n  , 1\n  /* PUSH */\n  ],\n  [\".\"\n  /* DOT */\n  ]: [2\n  /* BEFORE_IDENT */\n  , 1\n  /* PUSH */\n  ],\n  [\"[\"\n  /* LEFT_BRACKET */\n  ]: [4\n  /* IN_SUB_PATH */\n  , 1\n  /* PUSH */\n  ],\n  [\"o\"\n  /* END_OF_FAIL */\n  ]: [7\n  /* AFTER_PATH */\n  , 1\n  /* PUSH */\n  ]\n};\npathStateMachine[4\n/* IN_SUB_PATH */\n] = {\n  [\"'\"\n  /* SINGLE_QUOTE */\n  ]: [5\n  /* IN_SINGLE_QUOTE */\n  , 0\n  /* APPEND */\n  ],\n  [\"\\\"\"\n  /* DOUBLE_QUOTE */\n  ]: [6\n  /* IN_DOUBLE_QUOTE */\n  , 0\n  /* APPEND */\n  ],\n  [\"[\"\n  /* LEFT_BRACKET */\n  ]: [4\n  /* IN_SUB_PATH */\n  , 2\n  /* INC_SUB_PATH_DEPTH */\n  ],\n  [\"]\"\n  /* RIGHT_BRACKET */\n  ]: [1\n  /* IN_PATH */\n  , 3\n  /* PUSH_SUB_PATH */\n  ],\n  [\"o\"\n  /* END_OF_FAIL */\n  ]: 8\n  /* ERROR */\n  ,\n  [\"l\"\n  /* ELSE */\n  ]: [4\n  /* IN_SUB_PATH */\n  , 0\n  /* APPEND */\n  ]\n};\npathStateMachine[5\n/* IN_SINGLE_QUOTE */\n] = {\n  [\"'\"\n  /* SINGLE_QUOTE */\n  ]: [4\n  /* IN_SUB_PATH */\n  , 0\n  /* APPEND */\n  ],\n  [\"o\"\n  /* END_OF_FAIL */\n  ]: 8\n  /* ERROR */\n  ,\n  [\"l\"\n  /* ELSE */\n  ]: [5\n  /* IN_SINGLE_QUOTE */\n  , 0\n  /* APPEND */\n  ]\n};\npathStateMachine[6\n/* IN_DOUBLE_QUOTE */\n] = {\n  [\"\\\"\"\n  /* DOUBLE_QUOTE */\n  ]: [4\n  /* IN_SUB_PATH */\n  , 0\n  /* APPEND */\n  ],\n  [\"o\"\n  /* END_OF_FAIL */\n  ]: 8\n  /* ERROR */\n  ,\n  [\"l\"\n  /* ELSE */\n  ]: [6\n  /* IN_DOUBLE_QUOTE */\n  , 0\n  /* APPEND */\n  ]\n};\n/**\r\n * Check if an expression is a literal value.\r\n */\n\nconst literalValueRE = /^\\s?(?:true|false|-?[\\d.]+|'[^']*'|\"[^\"]*\")\\s?$/;\n\nfunction isLiteral(exp) {\n  return literalValueRE.test(exp);\n}\n/**\r\n * Strip quotes from a string\r\n */\n\n\nfunction stripQuotes(str) {\n  const a = str.charCodeAt(0);\n  const b = str.charCodeAt(str.length - 1);\n  return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;\n}\n/**\r\n * Determine the type of a character in a keypath.\r\n */\n\n\nfunction getPathCharType(ch) {\n  if (ch === undefined || ch === null) {\n    return \"o\"\n    /* END_OF_FAIL */\n    ;\n  }\n\n  const code = ch.charCodeAt(0);\n\n  switch (code) {\n    case 0x5b: // [\n\n    case 0x5d: // ]\n\n    case 0x2e: // .\n\n    case 0x22: // \"\n\n    case 0x27:\n      // '\n      return ch;\n\n    case 0x5f: // _\n\n    case 0x24: // $\n\n    case 0x2d:\n      // -\n      return \"i\"\n      /* IDENT */\n      ;\n\n    case 0x09: // Tab (HT)\n\n    case 0x0a: // Newline (LF)\n\n    case 0x0d: // Return (CR)\n\n    case 0xa0: // No-break space (NBSP)\n\n    case 0xfeff: // Byte Order Mark (BOM)\n\n    case 0x2028: // Line Separator (LS)\n\n    case 0x2029:\n      // Paragraph Separator (PS)\n      return \"w\"\n      /* WORKSPACE */\n      ;\n  }\n\n  return \"i\"\n  /* IDENT */\n  ;\n}\n/**\r\n * Format a subPath, return its plain form if it is\r\n * a literal string or number. Otherwise prepend the\r\n * dynamic indicator (*).\r\n */\n\n\nfunction formatSubPath(path) {\n  const trimmed = path.trim(); // invalid leading 0\n\n  if (path.charAt(0) === '0' && isNaN(parseInt(path))) {\n    return false;\n  }\n\n  return isLiteral(trimmed) ? stripQuotes(trimmed) : \"*\"\n  /* ASTARISK */\n  + trimmed;\n}\n/**\r\n * Parse a string path into an array of segments\r\n */\n\n\nfunction parse(path) {\n  const keys = [];\n  let index = -1;\n  let mode = 0\n  /* BEFORE_PATH */\n  ;\n  let subPathDepth = 0;\n  let c;\n  let key; // eslint-disable-line\n\n  let newChar;\n  let type;\n  let transition;\n  let action;\n  let typeMap;\n  const actions = [];\n\n  actions[0\n  /* APPEND */\n  ] = () => {\n    if (key === undefined) {\n      key = newChar;\n    } else {\n      key += newChar;\n    }\n  };\n\n  actions[1\n  /* PUSH */\n  ] = () => {\n    if (key !== undefined) {\n      keys.push(key);\n      key = undefined;\n    }\n  };\n\n  actions[2\n  /* INC_SUB_PATH_DEPTH */\n  ] = () => {\n    actions[0\n    /* APPEND */\n    ]();\n    subPathDepth++;\n  };\n\n  actions[3\n  /* PUSH_SUB_PATH */\n  ] = () => {\n    if (subPathDepth > 0) {\n      subPathDepth--;\n      mode = 4\n      /* IN_SUB_PATH */\n      ;\n      actions[0\n      /* APPEND */\n      ]();\n    } else {\n      subPathDepth = 0;\n\n      if (key === undefined) {\n        return false;\n      }\n\n      key = formatSubPath(key);\n\n      if (key === false) {\n        return false;\n      } else {\n        actions[1\n        /* PUSH */\n        ]();\n      }\n    }\n  };\n\n  function maybeUnescapeQuote() {\n    const nextChar = path[index + 1];\n\n    if (mode === 5\n    /* IN_SINGLE_QUOTE */\n    && nextChar === \"'\"\n    /* SINGLE_QUOTE */\n    || mode === 6\n    /* IN_DOUBLE_QUOTE */\n    && nextChar === \"\\\"\"\n    /* DOUBLE_QUOTE */\n    ) {\n      index++;\n      newChar = '\\\\' + nextChar;\n      actions[0\n      /* APPEND */\n      ]();\n      return true;\n    }\n  }\n\n  while (mode !== null) {\n    index++;\n    c = path[index];\n\n    if (c === '\\\\' && maybeUnescapeQuote()) {\n      continue;\n    }\n\n    type = getPathCharType(c);\n    typeMap = pathStateMachine[mode];\n    transition = typeMap[type] || typeMap[\"l\"\n    /* ELSE */\n    ] || 8\n    /* ERROR */\n    ; // check parse error\n\n    if (transition === 8\n    /* ERROR */\n    ) {\n      return;\n    }\n\n    mode = transition[0];\n\n    if (transition[1] !== undefined) {\n      action = actions[transition[1]];\n\n      if (action) {\n        newChar = c;\n\n        if (action() === false) {\n          return;\n        }\n      }\n    } // check parse finish\n\n\n    if (mode === 7\n    /* AFTER_PATH */\n    ) {\n      return keys;\n    }\n  }\n} // path token cache\n\n\nconst cache = new Map();\n\nfunction resolveValue(obj, path) {\n  // check object\n  if (!isObject(obj)) {\n    return null;\n  } // parse path\n\n\n  let hit = cache.get(path);\n\n  if (!hit) {\n    hit = parse(path);\n\n    if (hit) {\n      cache.set(path, hit);\n    }\n  } // check hit\n\n\n  if (!hit) {\n    return null;\n  } // resolve path value\n\n\n  const len = hit.length;\n  let last = obj;\n  let i = 0;\n\n  while (i < len) {\n    const val = last[hit[i]];\n\n    if (val === undefined) {\n      return null;\n    }\n\n    last = val;\n    i++;\n  }\n\n  return last;\n}\n/**\r\n * Transform flat json in obj to normal json in obj\r\n */\n\n\nfunction handleFlatJson(obj) {\n  // check obj\n  if (!isObject(obj)) {\n    return obj;\n  }\n\n  for (const key in obj) {\n    // check key\n    if (!hasOwn(obj, key)) {\n      continue;\n    } // handle for normal json\n\n\n    if (!key.includes(\".\"\n    /* DOT */\n    )) {\n      // recursive process value if value is also a object\n      if (isObject(obj[key])) {\n        handleFlatJson(obj[key]);\n      }\n    } // handle for flat json, transform to normal json\n    else {\n      // go to the last object\n      const subKeys = key.split(\".\"\n      /* DOT */\n      );\n      const lastIndex = subKeys.length - 1;\n      let currentObj = obj;\n\n      for (let i = 0; i < lastIndex; i++) {\n        if (!(subKeys[i] in currentObj)) {\n          currentObj[subKeys[i]] = {};\n        }\n\n        currentObj = currentObj[subKeys[i]];\n      } // update last object value, delete old property\n\n\n      currentObj[subKeys[lastIndex]] = obj[key];\n      delete obj[key]; // recursive process value if value is also a object\n\n      if (isObject(currentObj[subKeys[lastIndex]])) {\n        handleFlatJson(currentObj[subKeys[lastIndex]]);\n      }\n    }\n  }\n\n  return obj;\n}\n\nexport { handleFlatJson, parse, resolveValue };","map":{"version":3,"sources":["/Users/milo/Documents/Diverse/StariBar/front/stbar2/node_modules/@intlify/message-resolver/dist/message-resolver.esm-bundler.js"],"names":["process","env","NODE_ENV","hasOwnProperty","Object","prototype","hasOwn","obj","key","call","isObject","val","pathStateMachine","literalValueRE","isLiteral","exp","test","stripQuotes","str","a","charCodeAt","b","length","slice","getPathCharType","ch","undefined","code","formatSubPath","path","trimmed","trim","charAt","isNaN","parseInt","parse","keys","index","mode","subPathDepth","c","newChar","type","transition","action","typeMap","actions","push","maybeUnescapeQuote","nextChar","cache","Map","resolveValue","hit","get","set","len","last","i","handleFlatJson","includes","subKeys","split","lastIndex","currentObj"],"mappings":"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","sourcesContent":["/*!\n  * @intlify/message-resolver v9.1.9\n  * (c) 2021 kazuya kawaguchi\n  * Released under the MIT License.\n  */\n/**\r\n * Original Utilities\r\n * written by kazuya kawaguchi\r\n */\r\nif ((process.env.NODE_ENV !== 'production')) ;\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\r\nfunction hasOwn(obj, key) {\r\n    return hasOwnProperty.call(obj, key);\r\n}\r\nconst isObject = (val) => // eslint-disable-line\r\n val !== null && typeof val === 'object';\n\nconst pathStateMachine = [];\r\npathStateMachine[0 /* BEFORE_PATH */] = {\r\n    [\"w\" /* WORKSPACE */]: [0 /* BEFORE_PATH */],\r\n    [\"i\" /* IDENT */]: [3 /* IN_IDENT */, 0 /* APPEND */],\r\n    [\"[\" /* LEFT_BRACKET */]: [4 /* IN_SUB_PATH */],\r\n    [\"o\" /* END_OF_FAIL */]: [7 /* AFTER_PATH */]\r\n};\r\npathStateMachine[1 /* IN_PATH */] = {\r\n    [\"w\" /* WORKSPACE */]: [1 /* IN_PATH */],\r\n    [\".\" /* DOT */]: [2 /* BEFORE_IDENT */],\r\n    [\"[\" /* LEFT_BRACKET */]: [4 /* IN_SUB_PATH */],\r\n    [\"o\" /* END_OF_FAIL */]: [7 /* AFTER_PATH */]\r\n};\r\npathStateMachine[2 /* BEFORE_IDENT */] = {\r\n    [\"w\" /* WORKSPACE */]: [2 /* BEFORE_IDENT */],\r\n    [\"i\" /* IDENT */]: [3 /* IN_IDENT */, 0 /* APPEND */],\r\n    [\"0\" /* ZERO */]: [3 /* IN_IDENT */, 0 /* APPEND */]\r\n};\r\npathStateMachine[3 /* IN_IDENT */] = {\r\n    [\"i\" /* IDENT */]: [3 /* IN_IDENT */, 0 /* APPEND */],\r\n    [\"0\" /* ZERO */]: [3 /* IN_IDENT */, 0 /* APPEND */],\r\n    [\"w\" /* WORKSPACE */]: [1 /* IN_PATH */, 1 /* PUSH */],\r\n    [\".\" /* DOT */]: [2 /* BEFORE_IDENT */, 1 /* PUSH */],\r\n    [\"[\" /* LEFT_BRACKET */]: [4 /* IN_SUB_PATH */, 1 /* PUSH */],\r\n    [\"o\" /* END_OF_FAIL */]: [7 /* AFTER_PATH */, 1 /* PUSH */]\r\n};\r\npathStateMachine[4 /* IN_SUB_PATH */] = {\r\n    [\"'\" /* SINGLE_QUOTE */]: [5 /* IN_SINGLE_QUOTE */, 0 /* APPEND */],\r\n    [\"\\\"\" /* DOUBLE_QUOTE */]: [6 /* IN_DOUBLE_QUOTE */, 0 /* APPEND */],\r\n    [\"[\" /* LEFT_BRACKET */]: [\r\n        4 /* IN_SUB_PATH */,\r\n        2 /* INC_SUB_PATH_DEPTH */\r\n    ],\r\n    [\"]\" /* RIGHT_BRACKET */]: [1 /* IN_PATH */, 3 /* PUSH_SUB_PATH */],\r\n    [\"o\" /* END_OF_FAIL */]: 8 /* ERROR */,\r\n    [\"l\" /* ELSE */]: [4 /* IN_SUB_PATH */, 0 /* APPEND */]\r\n};\r\npathStateMachine[5 /* IN_SINGLE_QUOTE */] = {\r\n    [\"'\" /* SINGLE_QUOTE */]: [4 /* IN_SUB_PATH */, 0 /* APPEND */],\r\n    [\"o\" /* END_OF_FAIL */]: 8 /* ERROR */,\r\n    [\"l\" /* ELSE */]: [5 /* IN_SINGLE_QUOTE */, 0 /* APPEND */]\r\n};\r\npathStateMachine[6 /* IN_DOUBLE_QUOTE */] = {\r\n    [\"\\\"\" /* DOUBLE_QUOTE */]: [4 /* IN_SUB_PATH */, 0 /* APPEND */],\r\n    [\"o\" /* END_OF_FAIL */]: 8 /* ERROR */,\r\n    [\"l\" /* ELSE */]: [6 /* IN_DOUBLE_QUOTE */, 0 /* APPEND */]\r\n};\r\n/**\r\n * Check if an expression is a literal value.\r\n */\r\nconst literalValueRE = /^\\s?(?:true|false|-?[\\d.]+|'[^']*'|\"[^\"]*\")\\s?$/;\r\nfunction isLiteral(exp) {\r\n    return literalValueRE.test(exp);\r\n}\r\n/**\r\n * Strip quotes from a string\r\n */\r\nfunction stripQuotes(str) {\r\n    const a = str.charCodeAt(0);\r\n    const b = str.charCodeAt(str.length - 1);\r\n    return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;\r\n}\r\n/**\r\n * Determine the type of a character in a keypath.\r\n */\r\nfunction getPathCharType(ch) {\r\n    if (ch === undefined || ch === null) {\r\n        return \"o\" /* END_OF_FAIL */;\r\n    }\r\n    const code = ch.charCodeAt(0);\r\n    switch (code) {\r\n        case 0x5b: // [\r\n        case 0x5d: // ]\r\n        case 0x2e: // .\r\n        case 0x22: // \"\r\n        case 0x27: // '\r\n            return ch;\r\n        case 0x5f: // _\r\n        case 0x24: // $\r\n        case 0x2d: // -\r\n            return \"i\" /* IDENT */;\r\n        case 0x09: // Tab (HT)\r\n        case 0x0a: // Newline (LF)\r\n        case 0x0d: // Return (CR)\r\n        case 0xa0: // No-break space (NBSP)\r\n        case 0xfeff: // Byte Order Mark (BOM)\r\n        case 0x2028: // Line Separator (LS)\r\n        case 0x2029: // Paragraph Separator (PS)\r\n            return \"w\" /* WORKSPACE */;\r\n    }\r\n    return \"i\" /* IDENT */;\r\n}\r\n/**\r\n * Format a subPath, return its plain form if it is\r\n * a literal string or number. Otherwise prepend the\r\n * dynamic indicator (*).\r\n */\r\nfunction formatSubPath(path) {\r\n    const trimmed = path.trim();\r\n    // invalid leading 0\r\n    if (path.charAt(0) === '0' && isNaN(parseInt(path))) {\r\n        return false;\r\n    }\r\n    return isLiteral(trimmed)\r\n        ? stripQuotes(trimmed)\r\n        : \"*\" /* ASTARISK */ + trimmed;\r\n}\r\n/**\r\n * Parse a string path into an array of segments\r\n */\r\nfunction parse(path) {\r\n    const keys = [];\r\n    let index = -1;\r\n    let mode = 0 /* BEFORE_PATH */;\r\n    let subPathDepth = 0;\r\n    let c;\r\n    let key; // eslint-disable-line\r\n    let newChar;\r\n    let type;\r\n    let transition;\r\n    let action;\r\n    let typeMap;\r\n    const actions = [];\r\n    actions[0 /* APPEND */] = () => {\r\n        if (key === undefined) {\r\n            key = newChar;\r\n        }\r\n        else {\r\n            key += newChar;\r\n        }\r\n    };\r\n    actions[1 /* PUSH */] = () => {\r\n        if (key !== undefined) {\r\n            keys.push(key);\r\n            key = undefined;\r\n        }\r\n    };\r\n    actions[2 /* INC_SUB_PATH_DEPTH */] = () => {\r\n        actions[0 /* APPEND */]();\r\n        subPathDepth++;\r\n    };\r\n    actions[3 /* PUSH_SUB_PATH */] = () => {\r\n        if (subPathDepth > 0) {\r\n            subPathDepth--;\r\n            mode = 4 /* IN_SUB_PATH */;\r\n            actions[0 /* APPEND */]();\r\n        }\r\n        else {\r\n            subPathDepth = 0;\r\n            if (key === undefined) {\r\n                return false;\r\n            }\r\n            key = formatSubPath(key);\r\n            if (key === false) {\r\n                return false;\r\n            }\r\n            else {\r\n                actions[1 /* PUSH */]();\r\n            }\r\n        }\r\n    };\r\n    function maybeUnescapeQuote() {\r\n        const nextChar = path[index + 1];\r\n        if ((mode === 5 /* IN_SINGLE_QUOTE */ &&\r\n            nextChar === \"'\" /* SINGLE_QUOTE */) ||\r\n            (mode === 6 /* IN_DOUBLE_QUOTE */ &&\r\n                nextChar === \"\\\"\" /* DOUBLE_QUOTE */)) {\r\n            index++;\r\n            newChar = '\\\\' + nextChar;\r\n            actions[0 /* APPEND */]();\r\n            return true;\r\n        }\r\n    }\r\n    while (mode !== null) {\r\n        index++;\r\n        c = path[index];\r\n        if (c === '\\\\' && maybeUnescapeQuote()) {\r\n            continue;\r\n        }\r\n        type = getPathCharType(c);\r\n        typeMap = pathStateMachine[mode];\r\n        transition = typeMap[type] || typeMap[\"l\" /* ELSE */] || 8 /* ERROR */;\r\n        // check parse error\r\n        if (transition === 8 /* ERROR */) {\r\n            return;\r\n        }\r\n        mode = transition[0];\r\n        if (transition[1] !== undefined) {\r\n            action = actions[transition[1]];\r\n            if (action) {\r\n                newChar = c;\r\n                if (action() === false) {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        // check parse finish\r\n        if (mode === 7 /* AFTER_PATH */) {\r\n            return keys;\r\n        }\r\n    }\r\n}\r\n// path token cache\r\nconst cache = new Map();\r\nfunction resolveValue(obj, path) {\r\n    // check object\r\n    if (!isObject(obj)) {\r\n        return null;\r\n    }\r\n    // parse path\r\n    let hit = cache.get(path);\r\n    if (!hit) {\r\n        hit = parse(path);\r\n        if (hit) {\r\n            cache.set(path, hit);\r\n        }\r\n    }\r\n    // check hit\r\n    if (!hit) {\r\n        return null;\r\n    }\r\n    // resolve path value\r\n    const len = hit.length;\r\n    let last = obj;\r\n    let i = 0;\r\n    while (i < len) {\r\n        const val = last[hit[i]];\r\n        if (val === undefined) {\r\n            return null;\r\n        }\r\n        last = val;\r\n        i++;\r\n    }\r\n    return last;\r\n}\r\n/**\r\n * Transform flat json in obj to normal json in obj\r\n */\r\nfunction handleFlatJson(obj) {\r\n    // check obj\r\n    if (!isObject(obj)) {\r\n        return obj;\r\n    }\r\n    for (const key in obj) {\r\n        // check key\r\n        if (!hasOwn(obj, key)) {\r\n            continue;\r\n        }\r\n        // handle for normal json\r\n        if (!key.includes(\".\" /* DOT */)) {\r\n            // recursive process value if value is also a object\r\n            if (isObject(obj[key])) {\r\n                handleFlatJson(obj[key]);\r\n            }\r\n        }\r\n        // handle for flat json, transform to normal json\r\n        else {\r\n            // go to the last object\r\n            const subKeys = key.split(\".\" /* DOT */);\r\n            const lastIndex = subKeys.length - 1;\r\n            let currentObj = obj;\r\n            for (let i = 0; i < lastIndex; i++) {\r\n                if (!(subKeys[i] in currentObj)) {\r\n                    currentObj[subKeys[i]] = {};\r\n                }\r\n                currentObj = currentObj[subKeys[i]];\r\n            }\r\n            // update last object value, delete old property\r\n            currentObj[subKeys[lastIndex]] = obj[key];\r\n            delete obj[key];\r\n            // recursive process value if value is also a object\r\n            if (isObject(currentObj[subKeys[lastIndex]])) {\r\n                handleFlatJson(currentObj[subKeys[lastIndex]]);\r\n            }\r\n        }\r\n    }\r\n    return obj;\r\n}\n\nexport { handleFlatJson, parse, resolveValue };\n"]},"metadata":{},"sourceType":"module"}