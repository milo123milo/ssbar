{"ast":null,"code":"import { extend, isArray, isMap, isIntegerKey, hasOwn, isSymbol, isObject, hasChanged, makeMap, capitalize, toRawType, def, isFunction, NOOP } from '@vue/shared';\n\nfunction warn(msg, ...args) {\n  console.warn(`[Vue warn] ${msg}`, ...args);\n}\n\nlet activeEffectScope;\n\nclass EffectScope {\n  constructor(detached = false) {\n    this.detached = detached;\n    /**\n     * @internal\n     */\n\n    this._active = true;\n    /**\n     * @internal\n     */\n\n    this.effects = [];\n    /**\n     * @internal\n     */\n\n    this.cleanups = [];\n    this.parent = activeEffectScope;\n\n    if (!detached && activeEffectScope) {\n      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\n    }\n  }\n\n  get active() {\n    return this._active;\n  }\n\n  run(fn) {\n    if (this._active) {\n      const currentEffectScope = activeEffectScope;\n\n      try {\n        activeEffectScope = this;\n        return fn();\n      } finally {\n        activeEffectScope = currentEffectScope;\n      }\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(`cannot run an inactive effect scope.`);\n    }\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n\n\n  on() {\n    activeEffectScope = this;\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n\n\n  off() {\n    activeEffectScope = this.parent;\n  }\n\n  stop(fromParent) {\n    if (this._active) {\n      let i, l;\n\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].stop();\n      }\n\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\n        this.cleanups[i]();\n      }\n\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].stop(true);\n        }\n      }\n\n      if (!this.detached && this.parent && !fromParent) {\n        const last = this.parent.scopes.pop();\n\n        if (last && last !== this) {\n          this.parent.scopes[this.index] = last;\n          last.index = this.index;\n        }\n      }\n\n      this.parent = void 0;\n      this._active = false;\n    }\n  }\n\n}\n\nfunction effectScope(detached) {\n  return new EffectScope(detached);\n}\n\nfunction recordEffectScope(effect, scope = activeEffectScope) {\n  if (scope && scope.active) {\n    scope.effects.push(effect);\n  }\n}\n\nfunction getCurrentScope() {\n  return activeEffectScope;\n}\n\nfunction onScopeDispose(fn) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn);\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    warn(`onScopeDispose() is called when there is no active effect scope to be associated with.`);\n  }\n}\n\nconst createDep = effects => {\n  const dep = new Set(effects);\n  dep.w = 0;\n  dep.n = 0;\n  return dep;\n};\n\nconst wasTracked = dep => (dep.w & trackOpBit) > 0;\n\nconst newTracked = dep => (dep.n & trackOpBit) > 0;\n\nconst initDepMarkers = ({\n  deps\n}) => {\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].w |= trackOpBit;\n    }\n  }\n};\n\nconst finalizeDepMarkers = effect => {\n  const {\n    deps\n  } = effect;\n\n  if (deps.length) {\n    let ptr = 0;\n\n    for (let i = 0; i < deps.length; i++) {\n      const dep = deps[i];\n\n      if (wasTracked(dep) && !newTracked(dep)) {\n        dep.delete(effect);\n      } else {\n        deps[ptr++] = dep;\n      }\n\n      dep.w &= ~trackOpBit;\n      dep.n &= ~trackOpBit;\n    }\n\n    deps.length = ptr;\n  }\n};\n\nconst targetMap = /* @__PURE__ */new WeakMap();\nlet effectTrackDepth = 0;\nlet trackOpBit = 1;\nconst maxMarkerBits = 30;\nlet activeEffect;\nconst ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== \"production\") ? \"iterate\" : \"\");\nconst MAP_KEY_ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== \"production\") ? \"Map key iterate\" : \"\");\n\nclass ReactiveEffect {\n  constructor(fn, scheduler = null, scope) {\n    this.fn = fn;\n    this.scheduler = scheduler;\n    this.active = true;\n    this.deps = [];\n    this.parent = void 0;\n    recordEffectScope(this, scope);\n  }\n\n  run() {\n    if (!this.active) {\n      return this.fn();\n    }\n\n    let parent = activeEffect;\n    let lastShouldTrack = shouldTrack;\n\n    while (parent) {\n      if (parent === this) {\n        return;\n      }\n\n      parent = parent.parent;\n    }\n\n    try {\n      this.parent = activeEffect;\n      activeEffect = this;\n      shouldTrack = true;\n      trackOpBit = 1 << ++effectTrackDepth;\n\n      if (effectTrackDepth <= maxMarkerBits) {\n        initDepMarkers(this);\n      } else {\n        cleanupEffect(this);\n      }\n\n      return this.fn();\n    } finally {\n      if (effectTrackDepth <= maxMarkerBits) {\n        finalizeDepMarkers(this);\n      }\n\n      trackOpBit = 1 << --effectTrackDepth;\n      activeEffect = this.parent;\n      shouldTrack = lastShouldTrack;\n      this.parent = void 0;\n\n      if (this.deferStop) {\n        this.stop();\n      }\n    }\n  }\n\n  stop() {\n    if (activeEffect === this) {\n      this.deferStop = true;\n    } else if (this.active) {\n      cleanupEffect(this);\n\n      if (this.onStop) {\n        this.onStop();\n      }\n\n      this.active = false;\n    }\n  }\n\n}\n\nfunction cleanupEffect(effect2) {\n  const {\n    deps\n  } = effect2;\n\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].delete(effect2);\n    }\n\n    deps.length = 0;\n  }\n}\n\nfunction effect(fn, options) {\n  if (fn.effect) {\n    fn = fn.effect.fn;\n  }\n\n  const _effect = new ReactiveEffect(fn);\n\n  if (options) {\n    extend(_effect, options);\n    if (options.scope) recordEffectScope(_effect, options.scope);\n  }\n\n  if (!options || !options.lazy) {\n    _effect.run();\n  }\n\n  const runner = _effect.run.bind(_effect);\n\n  runner.effect = _effect;\n  return runner;\n}\n\nfunction stop(runner) {\n  runner.effect.stop();\n}\n\nlet shouldTrack = true;\nconst trackStack = [];\n\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\n\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\n\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === void 0 ? true : last;\n}\n\nfunction track(target, type, key) {\n  if (shouldTrack && activeEffect) {\n    let depsMap = targetMap.get(target);\n\n    if (!depsMap) {\n      targetMap.set(target, depsMap = /* @__PURE__ */new Map());\n    }\n\n    let dep = depsMap.get(key);\n\n    if (!dep) {\n      depsMap.set(key, dep = createDep());\n    }\n\n    const eventInfo = !!(process.env.NODE_ENV !== \"production\") ? {\n      effect: activeEffect,\n      target,\n      type,\n      key\n    } : void 0;\n    trackEffects(dep, eventInfo);\n  }\n}\n\nfunction trackEffects(dep, debuggerEventExtraInfo) {\n  let shouldTrack2 = false;\n\n  if (effectTrackDepth <= maxMarkerBits) {\n    if (!newTracked(dep)) {\n      dep.n |= trackOpBit;\n      shouldTrack2 = !wasTracked(dep);\n    }\n  } else {\n    shouldTrack2 = !dep.has(activeEffect);\n  }\n\n  if (shouldTrack2) {\n    dep.add(activeEffect);\n    activeEffect.deps.push(dep);\n\n    if (!!(process.env.NODE_ENV !== \"production\") && activeEffect.onTrack) {\n      activeEffect.onTrack(extend({\n        effect: activeEffect\n      }, debuggerEventExtraInfo));\n    }\n  }\n}\n\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target);\n\n  if (!depsMap) {\n    return;\n  }\n\n  let deps = [];\n\n  if (type === \"clear\") {\n    deps = [...depsMap.values()];\n  } else if (key === \"length\" && isArray(target)) {\n    const newLength = Number(newValue);\n    depsMap.forEach((dep, key2) => {\n      if (key2 === \"length\" || key2 >= newLength) {\n        deps.push(dep);\n      }\n    });\n  } else {\n    if (key !== void 0) {\n      deps.push(depsMap.get(key));\n    }\n\n    switch (type) {\n      case \"add\":\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        } else if (isIntegerKey(key)) {\n          deps.push(depsMap.get(\"length\"));\n        }\n\n        break;\n\n      case \"delete\":\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        }\n\n        break;\n\n      case \"set\":\n        if (isMap(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n        }\n\n        break;\n    }\n  }\n\n  const eventInfo = !!(process.env.NODE_ENV !== \"production\") ? {\n    target,\n    type,\n    key,\n    newValue,\n    oldValue,\n    oldTarget\n  } : void 0;\n\n  if (deps.length === 1) {\n    if (deps[0]) {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        triggerEffects(deps[0], eventInfo);\n      } else {\n        triggerEffects(deps[0]);\n      }\n    }\n  } else {\n    const effects = [];\n\n    for (const dep of deps) {\n      if (dep) {\n        effects.push(...dep);\n      }\n    }\n\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      triggerEffects(createDep(effects), eventInfo);\n    } else {\n      triggerEffects(createDep(effects));\n    }\n  }\n}\n\nfunction triggerEffects(dep, debuggerEventExtraInfo) {\n  const effects = isArray(dep) ? dep : [...dep];\n\n  for (const effect2 of effects) {\n    if (effect2.computed) {\n      triggerEffect(effect2, debuggerEventExtraInfo);\n    }\n  }\n\n  for (const effect2 of effects) {\n    if (!effect2.computed) {\n      triggerEffect(effect2, debuggerEventExtraInfo);\n    }\n  }\n}\n\nfunction triggerEffect(effect2, debuggerEventExtraInfo) {\n  if (effect2 !== activeEffect || effect2.allowRecurse) {\n    if (!!(process.env.NODE_ENV !== \"production\") && effect2.onTrigger) {\n      effect2.onTrigger(extend({\n        effect: effect2\n      }, debuggerEventExtraInfo));\n    }\n\n    if (effect2.scheduler) {\n      effect2.scheduler();\n    } else {\n      effect2.run();\n    }\n  }\n}\n\nfunction getDepFromReactive(object, key) {\n  var _a;\n\n  return (_a = targetMap.get(object)) == null ? void 0 : _a.get(key);\n}\n\nconst isNonTrackableKeys = /* @__PURE__ */makeMap(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set( /* @__PURE__ */Object.getOwnPropertyNames(Symbol).filter(key => key !== \"arguments\" && key !== \"caller\").map(key => Symbol[key]).filter(isSymbol));\nconst get$1 = /* @__PURE__ */createGetter();\nconst shallowGet = /* @__PURE__ */createGetter(false, true);\nconst readonlyGet = /* @__PURE__ */createGetter(true);\nconst shallowReadonlyGet = /* @__PURE__ */createGetter(true, true);\nconst arrayInstrumentations = /* @__PURE__ */createArrayInstrumentations();\n\nfunction createArrayInstrumentations() {\n  const instrumentations = {};\n  [\"includes\", \"indexOf\", \"lastIndexOf\"].forEach(key => {\n    instrumentations[key] = function (...args) {\n      const arr = toRaw(this);\n\n      for (let i = 0, l = this.length; i < l; i++) {\n        track(arr, \"get\", i + \"\");\n      }\n\n      const res = arr[key](...args);\n\n      if (res === -1 || res === false) {\n        return arr[key](...args.map(toRaw));\n      } else {\n        return res;\n      }\n    };\n  });\n  [\"push\", \"pop\", \"shift\", \"unshift\", \"splice\"].forEach(key => {\n    instrumentations[key] = function (...args) {\n      pauseTracking();\n      const res = toRaw(this)[key].apply(this, args);\n      resetTracking();\n      return res;\n    };\n  });\n  return instrumentations;\n}\n\nfunction hasOwnProperty(key) {\n  const obj = toRaw(this);\n  track(obj, \"has\", key);\n  return obj.hasOwnProperty(key);\n}\n\nfunction createGetter(isReadonly2 = false, shallow = false) {\n  return function get2(target, key, receiver) {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_isShallow\") {\n      return shallow;\n    } else if (key === \"__v_raw\" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {\n      return target;\n    }\n\n    const targetIsArray = isArray(target);\n\n    if (!isReadonly2) {\n      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {\n        return Reflect.get(arrayInstrumentations, key, receiver);\n      }\n\n      if (key === \"hasOwnProperty\") {\n        return hasOwnProperty;\n      }\n    }\n\n    const res = Reflect.get(target, key, receiver);\n\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n\n    if (!isReadonly2) {\n      track(target, \"get\", key);\n    }\n\n    if (shallow) {\n      return res;\n    }\n\n    if (isRef(res)) {\n      return targetIsArray && isIntegerKey(key) ? res : res.value;\n    }\n\n    if (isObject(res)) {\n      return isReadonly2 ? readonly(res) : reactive(res);\n    }\n\n    return res;\n  };\n}\n\nconst set$1 = /* @__PURE__ */createSetter();\nconst shallowSet = /* @__PURE__ */createSetter(true);\n\nfunction createSetter(shallow = false) {\n  return function set2(target, key, value, receiver) {\n    let oldValue = target[key];\n\n    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {\n      return false;\n    }\n\n    if (!shallow) {\n      if (!isShallow(value) && !isReadonly(value)) {\n        oldValue = toRaw(oldValue);\n        value = toRaw(value);\n      }\n\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n        oldValue.value = value;\n        return true;\n      }\n    }\n\n    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);\n    const result = Reflect.set(target, key, value, receiver);\n\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, \"add\", key, value);\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\", key, value, oldValue);\n      }\n    }\n\n    return result;\n  };\n}\n\nfunction deleteProperty(target, key) {\n  const hadKey = hasOwn(target, key);\n  const oldValue = target[key];\n  const result = Reflect.deleteProperty(target, key);\n\n  if (result && hadKey) {\n    trigger(target, \"delete\", key, void 0, oldValue);\n  }\n\n  return result;\n}\n\nfunction has$1(target, key) {\n  const result = Reflect.has(target, key);\n\n  if (!isSymbol(key) || !builtInSymbols.has(key)) {\n    track(target, \"has\", key);\n  }\n\n  return result;\n}\n\nfunction ownKeys(target) {\n  track(target, \"iterate\", isArray(target) ? \"length\" : ITERATE_KEY);\n  return Reflect.ownKeys(target);\n}\n\nconst mutableHandlers = {\n  get: get$1,\n  set: set$1,\n  deleteProperty,\n  has: has$1,\n  ownKeys\n};\nconst readonlyHandlers = {\n  get: readonlyGet,\n\n  set(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\n    }\n\n    return true;\n  },\n\n  deleteProperty(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\n    }\n\n    return true;\n  }\n\n};\nconst shallowReactiveHandlers = /* @__PURE__ */extend({}, mutableHandlers, {\n  get: shallowGet,\n  set: shallowSet\n});\nconst shallowReadonlyHandlers = /* @__PURE__ */extend({}, readonlyHandlers, {\n  get: shallowReadonlyGet\n});\n\nconst toShallow = value => value;\n\nconst getProto = v => Reflect.getPrototypeOf(v);\n\nfunction get(target, key, isReadonly = false, isShallow = false) {\n  target = target[\"__v_raw\"];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n\n  if (!isReadonly) {\n    if (key !== rawKey) {\n      track(rawTarget, \"get\", key);\n    }\n\n    track(rawTarget, \"get\", rawKey);\n  }\n\n  const {\n    has: has2\n  } = getProto(rawTarget);\n  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n\n  if (has2.call(rawTarget, key)) {\n    return wrap(target.get(key));\n  } else if (has2.call(rawTarget, rawKey)) {\n    return wrap(target.get(rawKey));\n  } else if (target !== rawTarget) {\n    target.get(key);\n  }\n}\n\nfunction has(key, isReadonly = false) {\n  const target = this[\"__v_raw\"];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n\n  if (!isReadonly) {\n    if (key !== rawKey) {\n      track(rawTarget, \"has\", key);\n    }\n\n    track(rawTarget, \"has\", rawKey);\n  }\n\n  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n}\n\nfunction size(target, isReadonly = false) {\n  target = target[\"__v_raw\"];\n  !isReadonly && track(toRaw(target), \"iterate\", ITERATE_KEY);\n  return Reflect.get(target, \"size\", target);\n}\n\nfunction add(value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const proto = getProto(target);\n  const hadKey = proto.has.call(target, value);\n\n  if (!hadKey) {\n    target.add(value);\n    trigger(target, \"add\", value, value);\n  }\n\n  return this;\n}\n\nfunction set(key, value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const {\n    has: has2,\n    get: get2\n  } = getProto(target);\n  let hadKey = has2.call(target, key);\n\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has2.call(target, key);\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    checkIdentityKeys(target, has2, key);\n  }\n\n  const oldValue = get2.call(target, key);\n  target.set(key, value);\n\n  if (!hadKey) {\n    trigger(target, \"add\", key, value);\n  } else if (hasChanged(value, oldValue)) {\n    trigger(target, \"set\", key, value, oldValue);\n  }\n\n  return this;\n}\n\nfunction deleteEntry(key) {\n  const target = toRaw(this);\n  const {\n    has: has2,\n    get: get2\n  } = getProto(target);\n  let hadKey = has2.call(target, key);\n\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has2.call(target, key);\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    checkIdentityKeys(target, has2, key);\n  }\n\n  const oldValue = get2 ? get2.call(target, key) : void 0;\n  const result = target.delete(key);\n\n  if (hadKey) {\n    trigger(target, \"delete\", key, void 0, oldValue);\n  }\n\n  return result;\n}\n\nfunction clear() {\n  const target = toRaw(this);\n  const hadItems = target.size !== 0;\n  const oldTarget = !!(process.env.NODE_ENV !== \"production\") ? isMap(target) ? new Map(target) : new Set(target) : void 0;\n  const result = target.clear();\n\n  if (hadItems) {\n    trigger(target, \"clear\", void 0, void 0, oldTarget);\n  }\n\n  return result;\n}\n\nfunction createForEach(isReadonly, isShallow) {\n  return function forEach(callback, thisArg) {\n    const observed = this;\n    const target = observed[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, \"iterate\", ITERATE_KEY);\n    return target.forEach((value, key) => {\n      return callback.call(thisArg, wrap(value), wrap(key), observed);\n    });\n  };\n}\n\nfunction createIterableMethod(method, isReadonly, isShallow) {\n  return function (...args) {\n    const target = this[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const targetIsMap = isMap(rawTarget);\n    const isPair = method === \"entries\" || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === \"keys\" && targetIsMap;\n    const innerIterator = target[method](...args);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, \"iterate\", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\n    return {\n      // iterator protocol\n      next() {\n        const {\n          value,\n          done\n        } = innerIterator.next();\n        return done ? {\n          value,\n          done\n        } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n\n    };\n  };\n}\n\nfunction createReadonlyMethod(type) {\n  return function (...args) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n      console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\n    }\n\n    return type === \"delete\" ? false : this;\n  };\n}\n\nfunction createInstrumentations() {\n  const mutableInstrumentations2 = {\n    get(key) {\n      return get(this, key);\n    },\n\n    get size() {\n      return size(this);\n    },\n\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, false)\n  };\n  const shallowInstrumentations2 = {\n    get(key) {\n      return get(this, key, false, true);\n    },\n\n    get size() {\n      return size(this);\n    },\n\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, true)\n  };\n  const readonlyInstrumentations2 = {\n    get(key) {\n      return get(this, key, true);\n    },\n\n    get size() {\n      return size(this, true);\n    },\n\n    has(key) {\n      return has.call(this, key, true);\n    },\n\n    add: createReadonlyMethod(\"add\"),\n    set: createReadonlyMethod(\"set\"),\n    delete: createReadonlyMethod(\"delete\"),\n    clear: createReadonlyMethod(\"clear\"),\n    forEach: createForEach(true, false)\n  };\n  const shallowReadonlyInstrumentations2 = {\n    get(key) {\n      return get(this, key, true, true);\n    },\n\n    get size() {\n      return size(this, true);\n    },\n\n    has(key) {\n      return has.call(this, key, true);\n    },\n\n    add: createReadonlyMethod(\"add\"),\n    set: createReadonlyMethod(\"set\"),\n    delete: createReadonlyMethod(\"delete\"),\n    clear: createReadonlyMethod(\"clear\"),\n    forEach: createForEach(true, true)\n  };\n  const iteratorMethods = [\"keys\", \"values\", \"entries\", Symbol.iterator];\n  iteratorMethods.forEach(method => {\n    mutableInstrumentations2[method] = createIterableMethod(method, false, false);\n    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);\n    shallowInstrumentations2[method] = createIterableMethod(method, false, true);\n    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);\n  });\n  return [mutableInstrumentations2, readonlyInstrumentations2, shallowInstrumentations2, shallowReadonlyInstrumentations2];\n}\n\nconst [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */createInstrumentations();\n\nfunction createInstrumentationGetter(isReadonly, shallow) {\n  const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;\n  return (target, key, receiver) => {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly;\n    } else if (key === \"__v_raw\") {\n      return target;\n    }\n\n    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);\n  };\n}\n\nconst mutableCollectionHandlers = {\n  get: /* @__PURE__ */createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n  get: /* @__PURE__ */createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n  get: /* @__PURE__ */createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n  get: /* @__PURE__ */createInstrumentationGetter(true, true)\n};\n\nfunction checkIdentityKeys(target, has2, key) {\n  const rawKey = toRaw(key);\n\n  if (rawKey !== key && has2.call(target, rawKey)) {\n    const type = toRawType(target);\n    console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);\n  }\n}\n\nconst reactiveMap = /* @__PURE__ */new WeakMap();\nconst shallowReactiveMap = /* @__PURE__ */new WeakMap();\nconst readonlyMap = /* @__PURE__ */new WeakMap();\nconst shallowReadonlyMap = /* @__PURE__ */new WeakMap();\n\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case \"Object\":\n    case \"Array\":\n      return 1\n      /* COMMON */\n      ;\n\n    case \"Map\":\n    case \"Set\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n      return 2\n      /* COLLECTION */\n      ;\n\n    default:\n      return 0\n      /* INVALID */\n      ;\n  }\n}\n\nfunction getTargetType(value) {\n  return value[\"__v_skip\"] || !Object.isExtensible(value) ? 0\n  /* INVALID */\n  : targetTypeMap(toRawType(value));\n}\n\nfunction reactive(target) {\n  if (isReadonly(target)) {\n    return target;\n  }\n\n  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\n}\n\nfunction shallowReactive(target) {\n  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\n}\n\nfunction readonly(target) {\n  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\n}\n\nfunction shallowReadonly(target) {\n  return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\n}\n\nfunction createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {\n  if (!isObject(target)) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      console.warn(`value cannot be made reactive: ${String(target)}`);\n    }\n\n    return target;\n  }\n\n  if (target[\"__v_raw\"] && !(isReadonly2 && target[\"__v_isReactive\"])) {\n    return target;\n  }\n\n  const existingProxy = proxyMap.get(target);\n\n  if (existingProxy) {\n    return existingProxy;\n  }\n\n  const targetType = getTargetType(target);\n\n  if (targetType === 0\n  /* INVALID */\n  ) {\n    return target;\n  }\n\n  const proxy = new Proxy(target, targetType === 2\n  /* COLLECTION */\n  ? collectionHandlers : baseHandlers);\n  proxyMap.set(target, proxy);\n  return proxy;\n}\n\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value[\"__v_raw\"]);\n  }\n\n  return !!(value && value[\"__v_isReactive\"]);\n}\n\nfunction isReadonly(value) {\n  return !!(value && value[\"__v_isReadonly\"]);\n}\n\nfunction isShallow(value) {\n  return !!(value && value[\"__v_isShallow\"]);\n}\n\nfunction isProxy(value) {\n  return isReactive(value) || isReadonly(value);\n}\n\nfunction toRaw(observed) {\n  const raw = observed && observed[\"__v_raw\"];\n  return raw ? toRaw(raw) : observed;\n}\n\nfunction markRaw(value) {\n  def(value, \"__v_skip\", true);\n  return value;\n}\n\nconst toReactive = value => isObject(value) ? reactive(value) : value;\n\nconst toReadonly = value => isObject(value) ? readonly(value) : value;\n\nfunction trackRefValue(ref2) {\n  if (shouldTrack && activeEffect) {\n    ref2 = toRaw(ref2);\n\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      trackEffects(ref2.dep || (ref2.dep = createDep()), {\n        target: ref2,\n        type: \"get\",\n        key: \"value\"\n      });\n    } else {\n      trackEffects(ref2.dep || (ref2.dep = createDep()));\n    }\n  }\n}\n\nfunction triggerRefValue(ref2, newVal) {\n  ref2 = toRaw(ref2);\n  const dep = ref2.dep;\n\n  if (dep) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      triggerEffects(dep, {\n        target: ref2,\n        type: \"set\",\n        key: \"value\",\n        newValue: newVal\n      });\n    } else {\n      triggerEffects(dep);\n    }\n  }\n}\n\nfunction isRef(r) {\n  return !!(r && r.__v_isRef === true);\n}\n\nfunction ref(value) {\n  return createRef(value, false);\n}\n\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\n\nfunction createRef(rawValue, shallow) {\n  if (isRef(rawValue)) {\n    return rawValue;\n  }\n\n  return new RefImpl(rawValue, shallow);\n}\n\nclass RefImpl {\n  constructor(value, __v_isShallow) {\n    this.__v_isShallow = __v_isShallow;\n    this.dep = void 0;\n    this.__v_isRef = true;\n    this._rawValue = __v_isShallow ? value : toRaw(value);\n    this._value = __v_isShallow ? value : toReactive(value);\n  }\n\n  get value() {\n    trackRefValue(this);\n    return this._value;\n  }\n\n  set value(newVal) {\n    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);\n    newVal = useDirectValue ? newVal : toRaw(newVal);\n\n    if (hasChanged(newVal, this._rawValue)) {\n      this._rawValue = newVal;\n      this._value = useDirectValue ? newVal : toReactive(newVal);\n      triggerRefValue(this, newVal);\n    }\n  }\n\n}\n\nfunction triggerRef(ref2) {\n  triggerRefValue(ref2, !!(process.env.NODE_ENV !== \"production\") ? ref2.value : void 0);\n}\n\nfunction unref(ref2) {\n  return isRef(ref2) ? ref2.value : ref2;\n}\n\nfunction toValue(source) {\n  return isFunction(source) ? source() : unref(source);\n}\n\nconst shallowUnwrapHandlers = {\n  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key];\n\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\n\nfunction proxyRefs(objectWithRefs) {\n  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\n\nclass CustomRefImpl {\n  constructor(factory) {\n    this.dep = void 0;\n    this.__v_isRef = true;\n    const {\n      get,\n      set\n    } = factory(() => trackRefValue(this), () => triggerRefValue(this));\n    this._get = get;\n    this._set = set;\n  }\n\n  get value() {\n    return this._get();\n  }\n\n  set value(newVal) {\n    this._set(newVal);\n  }\n\n}\n\nfunction customRef(factory) {\n  return new CustomRefImpl(factory);\n}\n\nfunction toRefs(object) {\n  if (!!(process.env.NODE_ENV !== \"production\") && !isProxy(object)) {\n    console.warn(`toRefs() expects a reactive object but received a plain one.`);\n  }\n\n  const ret = isArray(object) ? new Array(object.length) : {};\n\n  for (const key in object) {\n    ret[key] = propertyToRef(object, key);\n  }\n\n  return ret;\n}\n\nclass ObjectRefImpl {\n  constructor(_object, _key, _defaultValue) {\n    this._object = _object;\n    this._key = _key;\n    this._defaultValue = _defaultValue;\n    this.__v_isRef = true;\n  }\n\n  get value() {\n    const val = this._object[this._key];\n    return val === void 0 ? this._defaultValue : val;\n  }\n\n  set value(newVal) {\n    this._object[this._key] = newVal;\n  }\n\n  get dep() {\n    return getDepFromReactive(toRaw(this._object), this._key);\n  }\n\n}\n\nclass GetterRefImpl {\n  constructor(_getter) {\n    this._getter = _getter;\n    this.__v_isRef = true;\n    this.__v_isReadonly = true;\n  }\n\n  get value() {\n    return this._getter();\n  }\n\n}\n\nfunction toRef(source, key, defaultValue) {\n  if (isRef(source)) {\n    return source;\n  } else if (isFunction(source)) {\n    return new GetterRefImpl(source);\n  } else if (isObject(source) && arguments.length > 1) {\n    return propertyToRef(source, key, defaultValue);\n  } else {\n    return ref(source);\n  }\n}\n\nfunction propertyToRef(source, key, defaultValue) {\n  const val = source[key];\n  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);\n}\n\nclass ComputedRefImpl {\n  constructor(getter, _setter, isReadonly, isSSR) {\n    this._setter = _setter;\n    this.dep = void 0;\n    this.__v_isRef = true;\n    this[\"__v_isReadonly\"] = false;\n    this._dirty = true;\n    this.effect = new ReactiveEffect(getter, () => {\n      if (!this._dirty) {\n        this._dirty = true;\n        triggerRefValue(this);\n      }\n    });\n    this.effect.computed = this;\n    this.effect.active = this._cacheable = !isSSR;\n    this[\"__v_isReadonly\"] = isReadonly;\n  }\n\n  get value() {\n    const self = toRaw(this);\n    trackRefValue(self);\n\n    if (self._dirty || !self._cacheable) {\n      self._dirty = false;\n      self._value = self.effect.run();\n    }\n\n    return self._value;\n  }\n\n  set value(newValue) {\n    this._setter(newValue);\n  }\n\n}\n\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n  let getter;\n  let setter;\n  const onlyGetter = isFunction(getterOrOptions);\n\n  if (onlyGetter) {\n    getter = getterOrOptions;\n    setter = !!(process.env.NODE_ENV !== \"production\") ? () => {\n      console.warn(\"Write operation failed: computed value is readonly\");\n    } : NOOP;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n\n  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);\n\n  if (!!(process.env.NODE_ENV !== \"production\") && debugOptions && !isSSR) {\n    cRef.effect.onTrack = debugOptions.onTrack;\n    cRef.effect.onTrigger = debugOptions.onTrigger;\n  }\n\n  return cRef;\n}\n\nconst tick = /* @__PURE__ */Promise.resolve();\nconst queue = [];\nlet queued = false;\n\nconst scheduler = fn => {\n  queue.push(fn);\n\n  if (!queued) {\n    queued = true;\n    tick.then(flush);\n  }\n};\n\nconst flush = () => {\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]();\n  }\n\n  queue.length = 0;\n  queued = false;\n};\n\nclass DeferredComputedRefImpl {\n  constructor(getter) {\n    this.dep = void 0;\n    this._dirty = true;\n    this.__v_isRef = true;\n    this[\"__v_isReadonly\"] = true;\n    let compareTarget;\n    let hasCompareTarget = false;\n    let scheduled = false;\n    this.effect = new ReactiveEffect(getter, computedTrigger => {\n      if (this.dep) {\n        if (computedTrigger) {\n          compareTarget = this._value;\n          hasCompareTarget = true;\n        } else if (!scheduled) {\n          const valueToCompare = hasCompareTarget ? compareTarget : this._value;\n          scheduled = true;\n          hasCompareTarget = false;\n          scheduler(() => {\n            if (this.effect.active && this._get() !== valueToCompare) {\n              triggerRefValue(this);\n            }\n\n            scheduled = false;\n          });\n        }\n\n        for (const e of this.dep) {\n          if (e.computed instanceof DeferredComputedRefImpl) {\n            e.scheduler(true\n            /* computedTrigger */\n            );\n          }\n        }\n      }\n\n      this._dirty = true;\n    });\n    this.effect.computed = this;\n  }\n\n  _get() {\n    if (this._dirty) {\n      this._dirty = false;\n      return this._value = this.effect.run();\n    }\n\n    return this._value;\n  }\n\n  get value() {\n    trackRefValue(this);\n    return toRaw(this)._get();\n  }\n\n}\n\nfunction deferredComputed(getter) {\n  return new DeferredComputedRefImpl(getter);\n}\n\nexport { EffectScope, ITERATE_KEY, ReactiveEffect, computed, customRef, deferredComputed, effect, effectScope, enableTracking, getCurrentScope, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, onScopeDispose, pauseTracking, proxyRefs, reactive, readonly, ref, resetTracking, shallowReactive, shallowReadonly, shallowRef, stop, toRaw, toRef, toRefs, toValue, track, trigger, triggerRef, unref };","map":{"version":3,"sources":["/Users/milo/Documents/Diverse/meteo ui/stbar2/node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js"],"names":["extend","isArray","isMap","isIntegerKey","hasOwn","isSymbol","isObject","hasChanged","makeMap","capitalize","toRawType","def","isFunction","NOOP","warn","msg","args","console","activeEffectScope","EffectScope","constructor","detached","_active","effects","cleanups","parent","index","scopes","push","active","run","fn","currentEffectScope","process","env","NODE_ENV","on","off","stop","fromParent","i","l","length","last","pop","effectScope","recordEffectScope","effect","scope","getCurrentScope","onScopeDispose","createDep","dep","Set","w","n","wasTracked","trackOpBit","newTracked","initDepMarkers","deps","finalizeDepMarkers","ptr","delete","targetMap","WeakMap","effectTrackDepth","maxMarkerBits","activeEffect","ITERATE_KEY","Symbol","MAP_KEY_ITERATE_KEY","ReactiveEffect","scheduler","lastShouldTrack","shouldTrack","cleanupEffect","deferStop","onStop","effect2","options","_effect","lazy","runner","bind","trackStack","pauseTracking","enableTracking","resetTracking","track","target","type","key","depsMap","get","set","Map","eventInfo","trackEffects","debuggerEventExtraInfo","shouldTrack2","has","add","onTrack","trigger","newValue","oldValue","oldTarget","values","newLength","Number","forEach","key2","triggerEffects","computed","triggerEffect","allowRecurse","onTrigger","getDepFromReactive","object","_a","isNonTrackableKeys","builtInSymbols","Object","getOwnPropertyNames","filter","map","get$1","createGetter","shallowGet","readonlyGet","shallowReadonlyGet","arrayInstrumentations","createArrayInstrumentations","instrumentations","arr","toRaw","res","apply","hasOwnProperty","obj","isReadonly2","shallow","get2","receiver","shallowReadonlyMap","readonlyMap","shallowReactiveMap","reactiveMap","targetIsArray","Reflect","isRef","value","readonly","reactive","set$1","createSetter","shallowSet","set2","isReadonly","isShallow","hadKey","result","deleteProperty","has$1","ownKeys","mutableHandlers","readonlyHandlers","String","shallowReactiveHandlers","shallowReadonlyHandlers","toShallow","getProto","v","getPrototypeOf","rawTarget","rawKey","has2","wrap","toReadonly","toReactive","call","size","proto","checkIdentityKeys","deleteEntry","clear","hadItems","createForEach","callback","thisArg","observed","createIterableMethod","method","targetIsMap","isPair","iterator","isKeyOnly","innerIterator","next","done","createReadonlyMethod","createInstrumentations","mutableInstrumentations2","shallowInstrumentations2","readonlyInstrumentations2","shallowReadonlyInstrumentations2","iteratorMethods","mutableInstrumentations","readonlyInstrumentations","shallowInstrumentations","shallowReadonlyInstrumentations","createInstrumentationGetter","mutableCollectionHandlers","shallowCollectionHandlers","readonlyCollectionHandlers","shallowReadonlyCollectionHandlers","targetTypeMap","rawType","getTargetType","isExtensible","createReactiveObject","shallowReactive","shallowReadonly","baseHandlers","collectionHandlers","proxyMap","existingProxy","targetType","proxy","Proxy","isReactive","isProxy","raw","markRaw","trackRefValue","ref2","triggerRefValue","newVal","r","__v_isRef","ref","createRef","shallowRef","rawValue","RefImpl","__v_isShallow","_rawValue","_value","useDirectValue","triggerRef","unref","toValue","source","shallowUnwrapHandlers","proxyRefs","objectWithRefs","CustomRefImpl","factory","_get","_set","customRef","toRefs","ret","Array","propertyToRef","ObjectRefImpl","_object","_key","_defaultValue","val","GetterRefImpl","_getter","__v_isReadonly","toRef","defaultValue","arguments","ComputedRefImpl","getter","_setter","isSSR","_dirty","_cacheable","self","getterOrOptions","debugOptions","setter","onlyGetter","cRef","tick","Promise","resolve","queue","queued","then","flush","DeferredComputedRefImpl","compareTarget","hasCompareTarget","scheduled","computedTrigger","valueToCompare","e","deferredComputed"],"mappings":"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","sourcesContent":["import { extend, isArray, isMap, isIntegerKey, hasOwn, isSymbol, isObject, hasChanged, makeMap, capitalize, toRawType, def, isFunction, NOOP } from '@vue/shared';\n\nfunction warn(msg, ...args) {\n  console.warn(`[Vue warn] ${msg}`, ...args);\n}\n\nlet activeEffectScope;\nclass EffectScope {\n  constructor(detached = false) {\n    this.detached = detached;\n    /**\n     * @internal\n     */\n    this._active = true;\n    /**\n     * @internal\n     */\n    this.effects = [];\n    /**\n     * @internal\n     */\n    this.cleanups = [];\n    this.parent = activeEffectScope;\n    if (!detached && activeEffectScope) {\n      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(\n        this\n      ) - 1;\n    }\n  }\n  get active() {\n    return this._active;\n  }\n  run(fn) {\n    if (this._active) {\n      const currentEffectScope = activeEffectScope;\n      try {\n        activeEffectScope = this;\n        return fn();\n      } finally {\n        activeEffectScope = currentEffectScope;\n      }\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(`cannot run an inactive effect scope.`);\n    }\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  on() {\n    activeEffectScope = this;\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  off() {\n    activeEffectScope = this.parent;\n  }\n  stop(fromParent) {\n    if (this._active) {\n      let i, l;\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].stop();\n      }\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\n        this.cleanups[i]();\n      }\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].stop(true);\n        }\n      }\n      if (!this.detached && this.parent && !fromParent) {\n        const last = this.parent.scopes.pop();\n        if (last && last !== this) {\n          this.parent.scopes[this.index] = last;\n          last.index = this.index;\n        }\n      }\n      this.parent = void 0;\n      this._active = false;\n    }\n  }\n}\nfunction effectScope(detached) {\n  return new EffectScope(detached);\n}\nfunction recordEffectScope(effect, scope = activeEffectScope) {\n  if (scope && scope.active) {\n    scope.effects.push(effect);\n  }\n}\nfunction getCurrentScope() {\n  return activeEffectScope;\n}\nfunction onScopeDispose(fn) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn);\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    warn(\n      `onScopeDispose() is called when there is no active effect scope to be associated with.`\n    );\n  }\n}\n\nconst createDep = (effects) => {\n  const dep = new Set(effects);\n  dep.w = 0;\n  dep.n = 0;\n  return dep;\n};\nconst wasTracked = (dep) => (dep.w & trackOpBit) > 0;\nconst newTracked = (dep) => (dep.n & trackOpBit) > 0;\nconst initDepMarkers = ({ deps }) => {\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].w |= trackOpBit;\n    }\n  }\n};\nconst finalizeDepMarkers = (effect) => {\n  const { deps } = effect;\n  if (deps.length) {\n    let ptr = 0;\n    for (let i = 0; i < deps.length; i++) {\n      const dep = deps[i];\n      if (wasTracked(dep) && !newTracked(dep)) {\n        dep.delete(effect);\n      } else {\n        deps[ptr++] = dep;\n      }\n      dep.w &= ~trackOpBit;\n      dep.n &= ~trackOpBit;\n    }\n    deps.length = ptr;\n  }\n};\n\nconst targetMap = /* @__PURE__ */ new WeakMap();\nlet effectTrackDepth = 0;\nlet trackOpBit = 1;\nconst maxMarkerBits = 30;\nlet activeEffect;\nconst ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== \"production\") ? \"iterate\" : \"\");\nconst MAP_KEY_ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== \"production\") ? \"Map key iterate\" : \"\");\nclass ReactiveEffect {\n  constructor(fn, scheduler = null, scope) {\n    this.fn = fn;\n    this.scheduler = scheduler;\n    this.active = true;\n    this.deps = [];\n    this.parent = void 0;\n    recordEffectScope(this, scope);\n  }\n  run() {\n    if (!this.active) {\n      return this.fn();\n    }\n    let parent = activeEffect;\n    let lastShouldTrack = shouldTrack;\n    while (parent) {\n      if (parent === this) {\n        return;\n      }\n      parent = parent.parent;\n    }\n    try {\n      this.parent = activeEffect;\n      activeEffect = this;\n      shouldTrack = true;\n      trackOpBit = 1 << ++effectTrackDepth;\n      if (effectTrackDepth <= maxMarkerBits) {\n        initDepMarkers(this);\n      } else {\n        cleanupEffect(this);\n      }\n      return this.fn();\n    } finally {\n      if (effectTrackDepth <= maxMarkerBits) {\n        finalizeDepMarkers(this);\n      }\n      trackOpBit = 1 << --effectTrackDepth;\n      activeEffect = this.parent;\n      shouldTrack = lastShouldTrack;\n      this.parent = void 0;\n      if (this.deferStop) {\n        this.stop();\n      }\n    }\n  }\n  stop() {\n    if (activeEffect === this) {\n      this.deferStop = true;\n    } else if (this.active) {\n      cleanupEffect(this);\n      if (this.onStop) {\n        this.onStop();\n      }\n      this.active = false;\n    }\n  }\n}\nfunction cleanupEffect(effect2) {\n  const { deps } = effect2;\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].delete(effect2);\n    }\n    deps.length = 0;\n  }\n}\nfunction effect(fn, options) {\n  if (fn.effect) {\n    fn = fn.effect.fn;\n  }\n  const _effect = new ReactiveEffect(fn);\n  if (options) {\n    extend(_effect, options);\n    if (options.scope)\n      recordEffectScope(_effect, options.scope);\n  }\n  if (!options || !options.lazy) {\n    _effect.run();\n  }\n  const runner = _effect.run.bind(_effect);\n  runner.effect = _effect;\n  return runner;\n}\nfunction stop(runner) {\n  runner.effect.stop();\n}\nlet shouldTrack = true;\nconst trackStack = [];\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === void 0 ? true : last;\n}\nfunction track(target, type, key) {\n  if (shouldTrack && activeEffect) {\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n      depsMap.set(key, dep = createDep());\n    }\n    const eventInfo = !!(process.env.NODE_ENV !== \"production\") ? { effect: activeEffect, target, type, key } : void 0;\n    trackEffects(dep, eventInfo);\n  }\n}\nfunction trackEffects(dep, debuggerEventExtraInfo) {\n  let shouldTrack2 = false;\n  if (effectTrackDepth <= maxMarkerBits) {\n    if (!newTracked(dep)) {\n      dep.n |= trackOpBit;\n      shouldTrack2 = !wasTracked(dep);\n    }\n  } else {\n    shouldTrack2 = !dep.has(activeEffect);\n  }\n  if (shouldTrack2) {\n    dep.add(activeEffect);\n    activeEffect.deps.push(dep);\n    if (!!(process.env.NODE_ENV !== \"production\") && activeEffect.onTrack) {\n      activeEffect.onTrack(\n        extend(\n          {\n            effect: activeEffect\n          },\n          debuggerEventExtraInfo\n        )\n      );\n    }\n  }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) {\n    return;\n  }\n  let deps = [];\n  if (type === \"clear\") {\n    deps = [...depsMap.values()];\n  } else if (key === \"length\" && isArray(target)) {\n    const newLength = Number(newValue);\n    depsMap.forEach((dep, key2) => {\n      if (key2 === \"length\" || key2 >= newLength) {\n        deps.push(dep);\n      }\n    });\n  } else {\n    if (key !== void 0) {\n      deps.push(depsMap.get(key));\n    }\n    switch (type) {\n      case \"add\":\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        } else if (isIntegerKey(key)) {\n          deps.push(depsMap.get(\"length\"));\n        }\n        break;\n      case \"delete\":\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        }\n        break;\n      case \"set\":\n        if (isMap(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n        }\n        break;\n    }\n  }\n  const eventInfo = !!(process.env.NODE_ENV !== \"production\") ? { target, type, key, newValue, oldValue, oldTarget } : void 0;\n  if (deps.length === 1) {\n    if (deps[0]) {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        triggerEffects(deps[0], eventInfo);\n      } else {\n        triggerEffects(deps[0]);\n      }\n    }\n  } else {\n    const effects = [];\n    for (const dep of deps) {\n      if (dep) {\n        effects.push(...dep);\n      }\n    }\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      triggerEffects(createDep(effects), eventInfo);\n    } else {\n      triggerEffects(createDep(effects));\n    }\n  }\n}\nfunction triggerEffects(dep, debuggerEventExtraInfo) {\n  const effects = isArray(dep) ? dep : [...dep];\n  for (const effect2 of effects) {\n    if (effect2.computed) {\n      triggerEffect(effect2, debuggerEventExtraInfo);\n    }\n  }\n  for (const effect2 of effects) {\n    if (!effect2.computed) {\n      triggerEffect(effect2, debuggerEventExtraInfo);\n    }\n  }\n}\nfunction triggerEffect(effect2, debuggerEventExtraInfo) {\n  if (effect2 !== activeEffect || effect2.allowRecurse) {\n    if (!!(process.env.NODE_ENV !== \"production\") && effect2.onTrigger) {\n      effect2.onTrigger(extend({ effect: effect2 }, debuggerEventExtraInfo));\n    }\n    if (effect2.scheduler) {\n      effect2.scheduler();\n    } else {\n      effect2.run();\n    }\n  }\n}\nfunction getDepFromReactive(object, key) {\n  var _a;\n  return (_a = targetMap.get(object)) == null ? void 0 : _a.get(key);\n}\n\nconst isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set(\n  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== \"arguments\" && key !== \"caller\").map((key) => Symbol[key]).filter(isSymbol)\n);\nconst get$1 = /* @__PURE__ */ createGetter();\nconst shallowGet = /* @__PURE__ */ createGetter(false, true);\nconst readonlyGet = /* @__PURE__ */ createGetter(true);\nconst shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);\nconst arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();\nfunction createArrayInstrumentations() {\n  const instrumentations = {};\n  [\"includes\", \"indexOf\", \"lastIndexOf\"].forEach((key) => {\n    instrumentations[key] = function(...args) {\n      const arr = toRaw(this);\n      for (let i = 0, l = this.length; i < l; i++) {\n        track(arr, \"get\", i + \"\");\n      }\n      const res = arr[key](...args);\n      if (res === -1 || res === false) {\n        return arr[key](...args.map(toRaw));\n      } else {\n        return res;\n      }\n    };\n  });\n  [\"push\", \"pop\", \"shift\", \"unshift\", \"splice\"].forEach((key) => {\n    instrumentations[key] = function(...args) {\n      pauseTracking();\n      const res = toRaw(this)[key].apply(this, args);\n      resetTracking();\n      return res;\n    };\n  });\n  return instrumentations;\n}\nfunction hasOwnProperty(key) {\n  const obj = toRaw(this);\n  track(obj, \"has\", key);\n  return obj.hasOwnProperty(key);\n}\nfunction createGetter(isReadonly2 = false, shallow = false) {\n  return function get2(target, key, receiver) {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_isShallow\") {\n      return shallow;\n    } else if (key === \"__v_raw\" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {\n      return target;\n    }\n    const targetIsArray = isArray(target);\n    if (!isReadonly2) {\n      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {\n        return Reflect.get(arrayInstrumentations, key, receiver);\n      }\n      if (key === \"hasOwnProperty\") {\n        return hasOwnProperty;\n      }\n    }\n    const res = Reflect.get(target, key, receiver);\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n    if (!isReadonly2) {\n      track(target, \"get\", key);\n    }\n    if (shallow) {\n      return res;\n    }\n    if (isRef(res)) {\n      return targetIsArray && isIntegerKey(key) ? res : res.value;\n    }\n    if (isObject(res)) {\n      return isReadonly2 ? readonly(res) : reactive(res);\n    }\n    return res;\n  };\n}\nconst set$1 = /* @__PURE__ */ createSetter();\nconst shallowSet = /* @__PURE__ */ createSetter(true);\nfunction createSetter(shallow = false) {\n  return function set2(target, key, value, receiver) {\n    let oldValue = target[key];\n    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {\n      return false;\n    }\n    if (!shallow) {\n      if (!isShallow(value) && !isReadonly(value)) {\n        oldValue = toRaw(oldValue);\n        value = toRaw(value);\n      }\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n        oldValue.value = value;\n        return true;\n      }\n    }\n    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);\n    const result = Reflect.set(target, key, value, receiver);\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, \"add\", key, value);\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\", key, value, oldValue);\n      }\n    }\n    return result;\n  };\n}\nfunction deleteProperty(target, key) {\n  const hadKey = hasOwn(target, key);\n  const oldValue = target[key];\n  const result = Reflect.deleteProperty(target, key);\n  if (result && hadKey) {\n    trigger(target, \"delete\", key, void 0, oldValue);\n  }\n  return result;\n}\nfunction has$1(target, key) {\n  const result = Reflect.has(target, key);\n  if (!isSymbol(key) || !builtInSymbols.has(key)) {\n    track(target, \"has\", key);\n  }\n  return result;\n}\nfunction ownKeys(target) {\n  track(target, \"iterate\", isArray(target) ? \"length\" : ITERATE_KEY);\n  return Reflect.ownKeys(target);\n}\nconst mutableHandlers = {\n  get: get$1,\n  set: set$1,\n  deleteProperty,\n  has: has$1,\n  ownKeys\n};\nconst readonlyHandlers = {\n  get: readonlyGet,\n  set(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      );\n    }\n    return true;\n  },\n  deleteProperty(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `Delete operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      );\n    }\n    return true;\n  }\n};\nconst shallowReactiveHandlers = /* @__PURE__ */ extend(\n  {},\n  mutableHandlers,\n  {\n    get: shallowGet,\n    set: shallowSet\n  }\n);\nconst shallowReadonlyHandlers = /* @__PURE__ */ extend(\n  {},\n  readonlyHandlers,\n  {\n    get: shallowReadonlyGet\n  }\n);\n\nconst toShallow = (value) => value;\nconst getProto = (v) => Reflect.getPrototypeOf(v);\nfunction get(target, key, isReadonly = false, isShallow = false) {\n  target = target[\"__v_raw\"];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n  if (!isReadonly) {\n    if (key !== rawKey) {\n      track(rawTarget, \"get\", key);\n    }\n    track(rawTarget, \"get\", rawKey);\n  }\n  const { has: has2 } = getProto(rawTarget);\n  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n  if (has2.call(rawTarget, key)) {\n    return wrap(target.get(key));\n  } else if (has2.call(rawTarget, rawKey)) {\n    return wrap(target.get(rawKey));\n  } else if (target !== rawTarget) {\n    target.get(key);\n  }\n}\nfunction has(key, isReadonly = false) {\n  const target = this[\"__v_raw\"];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n  if (!isReadonly) {\n    if (key !== rawKey) {\n      track(rawTarget, \"has\", key);\n    }\n    track(rawTarget, \"has\", rawKey);\n  }\n  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n}\nfunction size(target, isReadonly = false) {\n  target = target[\"__v_raw\"];\n  !isReadonly && track(toRaw(target), \"iterate\", ITERATE_KEY);\n  return Reflect.get(target, \"size\", target);\n}\nfunction add(value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const proto = getProto(target);\n  const hadKey = proto.has.call(target, value);\n  if (!hadKey) {\n    target.add(value);\n    trigger(target, \"add\", value, value);\n  }\n  return this;\n}\nfunction set(key, value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const { has: has2, get: get2 } = getProto(target);\n  let hadKey = has2.call(target, key);\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has2.call(target, key);\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    checkIdentityKeys(target, has2, key);\n  }\n  const oldValue = get2.call(target, key);\n  target.set(key, value);\n  if (!hadKey) {\n    trigger(target, \"add\", key, value);\n  } else if (hasChanged(value, oldValue)) {\n    trigger(target, \"set\", key, value, oldValue);\n  }\n  return this;\n}\nfunction deleteEntry(key) {\n  const target = toRaw(this);\n  const { has: has2, get: get2 } = getProto(target);\n  let hadKey = has2.call(target, key);\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has2.call(target, key);\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    checkIdentityKeys(target, has2, key);\n  }\n  const oldValue = get2 ? get2.call(target, key) : void 0;\n  const result = target.delete(key);\n  if (hadKey) {\n    trigger(target, \"delete\", key, void 0, oldValue);\n  }\n  return result;\n}\nfunction clear() {\n  const target = toRaw(this);\n  const hadItems = target.size !== 0;\n  const oldTarget = !!(process.env.NODE_ENV !== \"production\") ? isMap(target) ? new Map(target) : new Set(target) : void 0;\n  const result = target.clear();\n  if (hadItems) {\n    trigger(target, \"clear\", void 0, void 0, oldTarget);\n  }\n  return result;\n}\nfunction createForEach(isReadonly, isShallow) {\n  return function forEach(callback, thisArg) {\n    const observed = this;\n    const target = observed[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, \"iterate\", ITERATE_KEY);\n    return target.forEach((value, key) => {\n      return callback.call(thisArg, wrap(value), wrap(key), observed);\n    });\n  };\n}\nfunction createIterableMethod(method, isReadonly, isShallow) {\n  return function(...args) {\n    const target = this[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const targetIsMap = isMap(rawTarget);\n    const isPair = method === \"entries\" || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === \"keys\" && targetIsMap;\n    const innerIterator = target[method](...args);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(\n      rawTarget,\n      \"iterate\",\n      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY\n    );\n    return {\n      // iterator protocol\n      next() {\n        const { value, done } = innerIterator.next();\n        return done ? { value, done } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n  };\n}\nfunction createReadonlyMethod(type) {\n  return function(...args) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n      console.warn(\n        `${capitalize(type)} operation ${key}failed: target is readonly.`,\n        toRaw(this)\n      );\n    }\n    return type === \"delete\" ? false : this;\n  };\n}\nfunction createInstrumentations() {\n  const mutableInstrumentations2 = {\n    get(key) {\n      return get(this, key);\n    },\n    get size() {\n      return size(this);\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, false)\n  };\n  const shallowInstrumentations2 = {\n    get(key) {\n      return get(this, key, false, true);\n    },\n    get size() {\n      return size(this);\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, true)\n  };\n  const readonlyInstrumentations2 = {\n    get(key) {\n      return get(this, key, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has.call(this, key, true);\n    },\n    add: createReadonlyMethod(\"add\"),\n    set: createReadonlyMethod(\"set\"),\n    delete: createReadonlyMethod(\"delete\"),\n    clear: createReadonlyMethod(\"clear\"),\n    forEach: createForEach(true, false)\n  };\n  const shallowReadonlyInstrumentations2 = {\n    get(key) {\n      return get(this, key, true, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has.call(this, key, true);\n    },\n    add: createReadonlyMethod(\"add\"),\n    set: createReadonlyMethod(\"set\"),\n    delete: createReadonlyMethod(\"delete\"),\n    clear: createReadonlyMethod(\"clear\"),\n    forEach: createForEach(true, true)\n  };\n  const iteratorMethods = [\"keys\", \"values\", \"entries\", Symbol.iterator];\n  iteratorMethods.forEach((method) => {\n    mutableInstrumentations2[method] = createIterableMethod(\n      method,\n      false,\n      false\n    );\n    readonlyInstrumentations2[method] = createIterableMethod(\n      method,\n      true,\n      false\n    );\n    shallowInstrumentations2[method] = createIterableMethod(\n      method,\n      false,\n      true\n    );\n    shallowReadonlyInstrumentations2[method] = createIterableMethod(\n      method,\n      true,\n      true\n    );\n  });\n  return [\n    mutableInstrumentations2,\n    readonlyInstrumentations2,\n    shallowInstrumentations2,\n    shallowReadonlyInstrumentations2\n  ];\n}\nconst [\n  mutableInstrumentations,\n  readonlyInstrumentations,\n  shallowInstrumentations,\n  shallowReadonlyInstrumentations\n] = /* @__PURE__ */ createInstrumentations();\nfunction createInstrumentationGetter(isReadonly, shallow) {\n  const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;\n  return (target, key, receiver) => {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly;\n    } else if (key === \"__v_raw\") {\n      return target;\n    }\n    return Reflect.get(\n      hasOwn(instrumentations, key) && key in target ? instrumentations : target,\n      key,\n      receiver\n    );\n  };\n}\nconst mutableCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, true)\n};\nfunction checkIdentityKeys(target, has2, key) {\n  const rawKey = toRaw(key);\n  if (rawKey !== key && has2.call(target, rawKey)) {\n    const type = toRawType(target);\n    console.warn(\n      `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`\n    );\n  }\n}\n\nconst reactiveMap = /* @__PURE__ */ new WeakMap();\nconst shallowReactiveMap = /* @__PURE__ */ new WeakMap();\nconst readonlyMap = /* @__PURE__ */ new WeakMap();\nconst shallowReadonlyMap = /* @__PURE__ */ new WeakMap();\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case \"Object\":\n    case \"Array\":\n      return 1 /* COMMON */;\n    case \"Map\":\n    case \"Set\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n      return 2 /* COLLECTION */;\n    default:\n      return 0 /* INVALID */;\n  }\n}\nfunction getTargetType(value) {\n  return value[\"__v_skip\"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap(toRawType(value));\n}\nfunction reactive(target) {\n  if (isReadonly(target)) {\n    return target;\n  }\n  return createReactiveObject(\n    target,\n    false,\n    mutableHandlers,\n    mutableCollectionHandlers,\n    reactiveMap\n  );\n}\nfunction shallowReactive(target) {\n  return createReactiveObject(\n    target,\n    false,\n    shallowReactiveHandlers,\n    shallowCollectionHandlers,\n    shallowReactiveMap\n  );\n}\nfunction readonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    readonlyHandlers,\n    readonlyCollectionHandlers,\n    readonlyMap\n  );\n}\nfunction shallowReadonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    shallowReadonlyHandlers,\n    shallowReadonlyCollectionHandlers,\n    shallowReadonlyMap\n  );\n}\nfunction createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {\n  if (!isObject(target)) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      console.warn(`value cannot be made reactive: ${String(target)}`);\n    }\n    return target;\n  }\n  if (target[\"__v_raw\"] && !(isReadonly2 && target[\"__v_isReactive\"])) {\n    return target;\n  }\n  const existingProxy = proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n  const targetType = getTargetType(target);\n  if (targetType === 0 /* INVALID */) {\n    return target;\n  }\n  const proxy = new Proxy(\n    target,\n    targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers\n  );\n  proxyMap.set(target, proxy);\n  return proxy;\n}\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value[\"__v_raw\"]);\n  }\n  return !!(value && value[\"__v_isReactive\"]);\n}\nfunction isReadonly(value) {\n  return !!(value && value[\"__v_isReadonly\"]);\n}\nfunction isShallow(value) {\n  return !!(value && value[\"__v_isShallow\"]);\n}\nfunction isProxy(value) {\n  return isReactive(value) || isReadonly(value);\n}\nfunction toRaw(observed) {\n  const raw = observed && observed[\"__v_raw\"];\n  return raw ? toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n  def(value, \"__v_skip\", true);\n  return value;\n}\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\n\nfunction trackRefValue(ref2) {\n  if (shouldTrack && activeEffect) {\n    ref2 = toRaw(ref2);\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      trackEffects(ref2.dep || (ref2.dep = createDep()), {\n        target: ref2,\n        type: \"get\",\n        key: \"value\"\n      });\n    } else {\n      trackEffects(ref2.dep || (ref2.dep = createDep()));\n    }\n  }\n}\nfunction triggerRefValue(ref2, newVal) {\n  ref2 = toRaw(ref2);\n  const dep = ref2.dep;\n  if (dep) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      triggerEffects(dep, {\n        target: ref2,\n        type: \"set\",\n        key: \"value\",\n        newValue: newVal\n      });\n    } else {\n      triggerEffects(dep);\n    }\n  }\n}\nfunction isRef(r) {\n  return !!(r && r.__v_isRef === true);\n}\nfunction ref(value) {\n  return createRef(value, false);\n}\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n  if (isRef(rawValue)) {\n    return rawValue;\n  }\n  return new RefImpl(rawValue, shallow);\n}\nclass RefImpl {\n  constructor(value, __v_isShallow) {\n    this.__v_isShallow = __v_isShallow;\n    this.dep = void 0;\n    this.__v_isRef = true;\n    this._rawValue = __v_isShallow ? value : toRaw(value);\n    this._value = __v_isShallow ? value : toReactive(value);\n  }\n  get value() {\n    trackRefValue(this);\n    return this._value;\n  }\n  set value(newVal) {\n    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);\n    newVal = useDirectValue ? newVal : toRaw(newVal);\n    if (hasChanged(newVal, this._rawValue)) {\n      this._rawValue = newVal;\n      this._value = useDirectValue ? newVal : toReactive(newVal);\n      triggerRefValue(this, newVal);\n    }\n  }\n}\nfunction triggerRef(ref2) {\n  triggerRefValue(ref2, !!(process.env.NODE_ENV !== \"production\") ? ref2.value : void 0);\n}\nfunction unref(ref2) {\n  return isRef(ref2) ? ref2.value : ref2;\n}\nfunction toValue(source) {\n  return isFunction(source) ? source() : unref(source);\n}\nconst shallowUnwrapHandlers = {\n  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key];\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\nfunction proxyRefs(objectWithRefs) {\n  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\nclass CustomRefImpl {\n  constructor(factory) {\n    this.dep = void 0;\n    this.__v_isRef = true;\n    const { get, set } = factory(\n      () => trackRefValue(this),\n      () => triggerRefValue(this)\n    );\n    this._get = get;\n    this._set = set;\n  }\n  get value() {\n    return this._get();\n  }\n  set value(newVal) {\n    this._set(newVal);\n  }\n}\nfunction customRef(factory) {\n  return new CustomRefImpl(factory);\n}\nfunction toRefs(object) {\n  if (!!(process.env.NODE_ENV !== \"production\") && !isProxy(object)) {\n    console.warn(`toRefs() expects a reactive object but received a plain one.`);\n  }\n  const ret = isArray(object) ? new Array(object.length) : {};\n  for (const key in object) {\n    ret[key] = propertyToRef(object, key);\n  }\n  return ret;\n}\nclass ObjectRefImpl {\n  constructor(_object, _key, _defaultValue) {\n    this._object = _object;\n    this._key = _key;\n    this._defaultValue = _defaultValue;\n    this.__v_isRef = true;\n  }\n  get value() {\n    const val = this._object[this._key];\n    return val === void 0 ? this._defaultValue : val;\n  }\n  set value(newVal) {\n    this._object[this._key] = newVal;\n  }\n  get dep() {\n    return getDepFromReactive(toRaw(this._object), this._key);\n  }\n}\nclass GetterRefImpl {\n  constructor(_getter) {\n    this._getter = _getter;\n    this.__v_isRef = true;\n    this.__v_isReadonly = true;\n  }\n  get value() {\n    return this._getter();\n  }\n}\nfunction toRef(source, key, defaultValue) {\n  if (isRef(source)) {\n    return source;\n  } else if (isFunction(source)) {\n    return new GetterRefImpl(source);\n  } else if (isObject(source) && arguments.length > 1) {\n    return propertyToRef(source, key, defaultValue);\n  } else {\n    return ref(source);\n  }\n}\nfunction propertyToRef(source, key, defaultValue) {\n  const val = source[key];\n  return isRef(val) ? val : new ObjectRefImpl(\n    source,\n    key,\n    defaultValue\n  );\n}\n\nclass ComputedRefImpl {\n  constructor(getter, _setter, isReadonly, isSSR) {\n    this._setter = _setter;\n    this.dep = void 0;\n    this.__v_isRef = true;\n    this[\"__v_isReadonly\"] = false;\n    this._dirty = true;\n    this.effect = new ReactiveEffect(getter, () => {\n      if (!this._dirty) {\n        this._dirty = true;\n        triggerRefValue(this);\n      }\n    });\n    this.effect.computed = this;\n    this.effect.active = this._cacheable = !isSSR;\n    this[\"__v_isReadonly\"] = isReadonly;\n  }\n  get value() {\n    const self = toRaw(this);\n    trackRefValue(self);\n    if (self._dirty || !self._cacheable) {\n      self._dirty = false;\n      self._value = self.effect.run();\n    }\n    return self._value;\n  }\n  set value(newValue) {\n    this._setter(newValue);\n  }\n}\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n  let getter;\n  let setter;\n  const onlyGetter = isFunction(getterOrOptions);\n  if (onlyGetter) {\n    getter = getterOrOptions;\n    setter = !!(process.env.NODE_ENV !== \"production\") ? () => {\n      console.warn(\"Write operation failed: computed value is readonly\");\n    } : NOOP;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);\n  if (!!(process.env.NODE_ENV !== \"production\") && debugOptions && !isSSR) {\n    cRef.effect.onTrack = debugOptions.onTrack;\n    cRef.effect.onTrigger = debugOptions.onTrigger;\n  }\n  return cRef;\n}\n\nconst tick = /* @__PURE__ */ Promise.resolve();\nconst queue = [];\nlet queued = false;\nconst scheduler = (fn) => {\n  queue.push(fn);\n  if (!queued) {\n    queued = true;\n    tick.then(flush);\n  }\n};\nconst flush = () => {\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]();\n  }\n  queue.length = 0;\n  queued = false;\n};\nclass DeferredComputedRefImpl {\n  constructor(getter) {\n    this.dep = void 0;\n    this._dirty = true;\n    this.__v_isRef = true;\n    this[\"__v_isReadonly\"] = true;\n    let compareTarget;\n    let hasCompareTarget = false;\n    let scheduled = false;\n    this.effect = new ReactiveEffect(getter, (computedTrigger) => {\n      if (this.dep) {\n        if (computedTrigger) {\n          compareTarget = this._value;\n          hasCompareTarget = true;\n        } else if (!scheduled) {\n          const valueToCompare = hasCompareTarget ? compareTarget : this._value;\n          scheduled = true;\n          hasCompareTarget = false;\n          scheduler(() => {\n            if (this.effect.active && this._get() !== valueToCompare) {\n              triggerRefValue(this);\n            }\n            scheduled = false;\n          });\n        }\n        for (const e of this.dep) {\n          if (e.computed instanceof DeferredComputedRefImpl) {\n            e.scheduler(\n              true\n              /* computedTrigger */\n            );\n          }\n        }\n      }\n      this._dirty = true;\n    });\n    this.effect.computed = this;\n  }\n  _get() {\n    if (this._dirty) {\n      this._dirty = false;\n      return this._value = this.effect.run();\n    }\n    return this._value;\n  }\n  get value() {\n    trackRefValue(this);\n    return toRaw(this)._get();\n  }\n}\nfunction deferredComputed(getter) {\n  return new DeferredComputedRefImpl(getter);\n}\n\nexport { EffectScope, ITERATE_KEY, ReactiveEffect, computed, customRef, deferredComputed, effect, effectScope, enableTracking, getCurrentScope, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, onScopeDispose, pauseTracking, proxyRefs, reactive, readonly, ref, resetTracking, shallowReactive, shallowReadonly, shallowRef, stop, toRaw, toRef, toRefs, toValue, track, trigger, triggerRef, unref };\n"]},"metadata":{},"sourceType":"module"}